"use strict";(self.webpackChunkdocs_1=self.webpackChunkdocs_1||[]).push([[9136],{3905:function(t,n,e){e.d(n,{Zo:function(){return p},kt:function(){return d}});var a=e(7294);function i(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function s(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,a)}return e}function r(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?s(Object(e),!0).forEach((function(n){i(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):s(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function o(t,n){if(null==t)return{};var e,a,i=function(t,n){if(null==t)return{};var e,a,i={},s=Object.keys(t);for(a=0;a<s.length;a++)e=s[a],n.indexOf(e)>=0||(i[e]=t[e]);return i}(t,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(t);for(a=0;a<s.length;a++)e=s[a],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(i[e]=t[e])}return i}var c=a.createContext({}),l=function(t){var n=a.useContext(c),e=n;return t&&(e="function"==typeof t?t(n):r(r({},n),t)),e},p=function(t){var n=l(t.components);return a.createElement(c.Provider,{value:n},t.children)},h={inlineCode:"code",wrapper:function(t){var n=t.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(t,n){var e=t.components,i=t.mdxType,s=t.originalType,c=t.parentName,p=o(t,["components","mdxType","originalType","parentName"]),u=l(e),d=i,m=u["".concat(c,".").concat(d)]||u[d]||h[d]||s;return e?a.createElement(m,r(r({ref:n},p),{},{components:e})):a.createElement(m,r({ref:n},p))}));function d(t,n){var e=arguments,i=n&&n.mdxType;if("string"==typeof t||i){var s=e.length,r=new Array(s);r[0]=u;var o={};for(var c in n)hasOwnProperty.call(n,c)&&(o[c]=n[c]);o.originalType=t,o.mdxType="string"==typeof t?t:i,r[1]=o;for(var l=2;l<s;l++)r[l]=e[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,e)}u.displayName="MDXCreateElement"},1198:function(t,n,e){e.r(n),e.d(n,{assets:function(){return p},contentTitle:function(){return c},default:function(){return d},frontMatter:function(){return o},metadata:function(){return l},toc:function(){return h}});var a=e(7462),i=e(3366),s=(e(7294),e(3905)),r=["components"],o={sidebar_position:5},c="Client Applications",l={unversionedId:"xcm/building-with-xcm/client-applications",id:"xcm/building-with-xcm/client-applications",title:"Client Applications",description:"In this chapter, we will look into how we can use TypeScript to interact with the XCM pallet and construct XCM transactions. With this information, you can create your XCM dApp or bridges.",source:"@site/docs/xcm/building-with-xcm/client-applications.md",sourceDirName:"xcm/building-with-xcm",slug:"/xcm/building-with-xcm/client-applications",permalink:"/docs/xcm/building-with-xcm/client-applications",editUrl:"https://github.com/AstarNetwork/astar-docs/tree/main/docs/xcm/building-with-xcm/client-applications.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"XCM with dApps",permalink:"/docs/xcm/building-with-xcm/xcm-with-dapps"},next:{title:"FAQ for Smart Contracts",permalink:"/docs/xcm/building-with-xcm/faq-for-smart-contracts"}},p={},h=[],u={toc:h};function d(t){var n=t.components,e=(0,i.Z)(t,r);return(0,s.kt)("wrapper",(0,a.Z)({},u,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"client-applications"},"Client Applications"),(0,s.kt)("p",null,"In this chapter, we will look into how we can use TypeScript to interact with the XCM pallet and construct XCM transactions. With this information, you can create your XCM dApp or bridges."),(0,s.kt)("p",null,"Because we need to interact with the XCM pallet via the Substrate RPC, we will use the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/polkadot-js/api"},(0,s.kt)("inlineCode",{parentName:"a"},"polkadot/api"))," package throughout this chapter."),(0,s.kt)("p",null,"First, you need to initialize the API like you would with any Substrate application."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst myApp = async () => {\n    const provider = new WsProvider('wss://rpc.shiden.astar.network');\n    const chainApi = await (new ApiPromise({ provider })).isReady;\n\n  const paraId = await chainApi.query.parachainInfo.parachainId.toString();\n \n  // Should output 2007\n  console.log(paraId)\n};\n")),(0,s.kt)("p",null,"In Astar Network, we use the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/paritytech/substrate/tree/master/frame/assets"},"Substrate Assets pallet")," to handle the XCM multi-asset representation. Let\u2019s try to get the list of assets from the network."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"}," \n// import the known types\nimport { AssetMetadata, AssetDetails } from '@polkadot/types/interfaces';\n\n// we create a custom interface for convenience\ninterface ChainAsset extends AssetDetails {\n    id: string;\n    metadata: AssetMetadata;\n}\n\n  //...snip\n\n  // note that this function requires the chain to implement the Assets pallet\n\n    // note: The asset ID will have different meanings depending on the range\n    // 1 ~ 2^32-1 = User-defined assets. Anyone can register this assets on chain.\n    // 2^32 ~ 2^64-1 = Statemine/Statemint assets map. This is a direct map of all the assets stored in the common-goods state chain.\n    // 2^64 ~ 2^128-1 = Ecosystem assets like native assets on another parachain or other valuable tokens.\n    // 2^128 ~ 1 = Relaychain native token (DOT or KSM).\n\n    const assetsListRaw = await chainApi.query.assets.asset.entries();\n    const assetMetadataListRaw = await chainApi.query.assets.metadata.entries();\n\n    const assetInfos = assetsListRaw.map((i, index) => {\n        const assetId = (i[0].toHuman() as string[])[0].replaceAll(',', '');\n        const assetInfo = i[1].toHuman() as any as AssetDetails;\n        const metadata = assetMetadataListRaw[index][1].toHuman() as any as AssetMetadata;\n        return {\n            id: assetId,\n            ...assetInfo,\n            metadata,\n        } as ChainAsset;\n    });\n    // convert the list into a string array of numbers without the comma and no nested entries\n};\n")),(0,s.kt)("p",null,"Running this function should give you the list of assets that are registered on the chain. This is useful when you want to create a UI that lists all possible assets and XCM-compatible assets too."),(0,s.kt)("p",null,"Next, let\u2019s try executing a cross-consensus function. Parachains will have the pallet called ",(0,s.kt)("inlineCode",{parentName:"p"},"polkadotXcm"),", while relaychains will use the pallet ",(0,s.kt)("inlineCode",{parentName:"p"},"xcmPallet"),". Both of them will have the same function and syntax for sending XCM transactions."),(0,s.kt)("p",null,"For this example, we\u2019ll send the relaychain asset to the parachain, which is what we did in the previous chapters, but here, we\u2019ll do it in TypeScript."),(0,s.kt)("p",null,"Let\u2019s first create two API instances, one for the parachain and the other for the relaychain. Although for our example, we will only call the extrinsic from the relaychain, we will initialize the parachain API instance to dynamically obtain the parachain ID."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Vec, u32 } from '@polkadot/types';\n\nconst parachainApi = async () => {\n    const provider = new WsProvider('wss://rpc.shiden.astar.network');\n    const chainApi = await (new ApiPromise({ provider })).isReady;\n\n    const paraId = (await chainApi.query.parachainInfo.parachainId()).toString();\n\n    // Should output 2007\n    console.log(paraId);\n    return chainApi;\n};\n\nconst relaychainApi = async () => {\n    const provider = new WsProvider('wss://kusama-rpc.polkadot.io');\n    const chainApi = await (new ApiPromise({ provider })).isReady;\n\n    const parachains = ((await chainApi.query.paras.parachains()) as Vec<u32>).map((i) => i.toNumber());\n\n    // Should output a list of parachain IDs\n    console.log(parachains);\n    return chainApi;\n};\n")),(0,s.kt)("p",null,"Next, we create the main function for handling the actual XCM transaction."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"import { Keyring } from '@polkadot/keyring';\nimport { decodeAddress, cryptoWaitReady } from '@polkadot/util-crypto';\n\nconst myApp = async () => {\n  await cryptoWaitReady();\n\n    const keyring = new Keyring({ type: 'sr25519' });\n    // ensure that this account has some KSM\n    const account = keyring.addFromUri('account seed', { name: 'Default' }, 'sr25519');\n\n    const parachainApiInst = await parachainApi();\n    const relaychainApiInst = await relaychainApi();\n\n    const parachainId = await parachainApiInst.query.parachainInfo.parachainId.toString();\n    \n    // the target parachain connected to the current relaychain\n    const dest = {\n        V1: {\n            interior: {\n                X1: {\n                    Parachain: parachainId,\n                },\n            },\n            parents: 0,\n        },\n    };\n    // the account ID within the destination parachain\n    const beneficiary = {\n        V1: {\n            interior: {\n                X1: {\n                    AccountId32: {\n                        network: 'Any',\n                        id: decodeAddress(account.address),\n                    },\n                },\n            },\n            parents: 0,\n        },\n    };\n\n  // 1 KSM\n    const amountToSend = new BN(10).pow(new BN(12));\n    // amount of fungible tokens to be transferred\n    const assets = {\n        V1: [\n            {\n                fun: {\n                    Fungible: amountToSend,\n                },\n                id: {\n                    Concrete: {\n                        interior: 'Here',\n                        parents: 0,\n                    },\n                },\n            },\n        ],\n    };\n\n    const txHash = await relaychainApiInst.tx.xcmPallet.reserveTransferAssets(dest, beneficiary, assets, 0).signAndSend(account);\n};\n")),(0,s.kt)("p",null,"The first half of the function is about loading the account that will send the KSM and initializing the API. The real magic happens in the latter half of the function."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"    // the target parachain connected to the current relaychain\n    const dest = {\n        V1: {\n            interior: {\n                X1: {\n                    Parachain: parachainId,\n                },\n            },\n            parents: 0,\n        },\n    };\n    // the account ID within the destination parachain\n    const beneficiary = {\n        V1: {\n            interior: {\n                X1: {\n                    AccountId32: {\n                        network: 'Any',\n                        id: decodeAddress(account.address),\n                    },\n                },\n            },\n            parents: 0,\n        },\n    };\n\n  // 1 KSM\n    const amountToSend = new BN(10).pow(new BN(12));\n    // amount of fungible tokens to be transferred\n    const assets = {\n        V1: [\n            {\n                fun: {\n                    Fungible: amountToSend,\n                },\n                id: {\n                    Concrete: {\n                        interior: 'Here',\n                        parents: 0,\n                    },\n                },\n            },\n        ],\n    };\n")),(0,s.kt)("p",null,"As you can see, the ",(0,s.kt)("inlineCode",{parentName:"p"},"dest")," refers to the destination or the target chain that will receive the asset identified by the parachain ID. The ",(0,s.kt)("inlineCode",{parentName:"p"},"beneficiary")," refers to the account within the parachain that will receive the token. Finally, the ",(0,s.kt)("inlineCode",{parentName:"p"},"assets")," parameter simply refers to the amount you wish to send. Finally, we can sign the transaction with the following function:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"// This can be zero\nconst feeAsset = 0;\nconst txHash = await relaychainApiInst.tx.xcmPallet.reserveTransferAssets(dest, beneficiary, assets, feeAsset).signAndSend(account);\n")),(0,s.kt)("p",null,"Now once you finish the XCM transaction, you can list all the assets with the following script:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const assetsListRaw = await parachainApiInst.query.assets.asset.entries();\nconst assetMetadataListRaw = await parachainApiInst.query.assets.metadata.entries();\n\nconst assetInfos = assetsListRaw.map((i, index) => {\n    const assetId = (i[0].toHuman() as string[])[0].replaceAll(',', '');\n    const assetInfo = i[1].toHuman() as any as AssetDetails;\n    const metadata = assetMetadataListRaw[index][1].toHuman() as any as AssetMetadata;\n    return {\n        id: assetId,\n        ...assetInfo,\n        metadata,\n    } as ChainAsset;\n});\n\nconst assetBalance = await Promise.all(assetInfos.map(async (i) => {\n    const balance = await parachainApiInst.query.assets.account(i.id, account.address);\n    return {\n        symbol: i.metadata.symbol.toString(),\n        balance: balance.toString(),\n    }\n}))\n\nconsole.log(assetBalance);\n")),(0,s.kt)("p",null,"Now, you should be able to transfer the asset from the relaychain to the parachain, and check if it was successful by listing all the assets within the asset pallet that the current account holds."),(0,s.kt)("p",null,"Please note that the gas amount will be deduced from the transferred amount. Transferred amount should be adjusted with gas fee estimate. Please refer to ",(0,s.kt)("a",{parentName:"p",href:"https://app.gitbook.com/o/-LgGrgOEDyFYjYWIb1DT/s/-M8GVK5H7hOsGnYqg-7q-872737601/~/changes/aJQFFWQNMjlao1SSjj4a/build/api/gas-price-api"},"Gas Price API")," if needed for specific use case."),(0,s.kt)("p",null,"You can find the full project that deals with similar functionality from ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/AstarNetwork/astar-xcm-tools"},"this repository"),"."))}d.isMDXComponent=!0}}]);