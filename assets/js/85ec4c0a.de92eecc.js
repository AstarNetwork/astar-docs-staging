"use strict";(self.webpackChunkdocs_1=self.webpackChunkdocs_1||[]).push([[1044],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return d}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=c(n),d=a,f=m["".concat(l,".").concat(d)]||m[d]||u[d]||o;return n?r.createElement(f,i(i({ref:t},p),{},{components:n})):r.createElement(f,i({ref:t},p))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1425:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return u}});var r=n(7462),a=n(3366),o=(n(7294),n(3905)),i=["components"],s={sidebar_position:3},l="Libraries",c={unversionedId:"wasm/sc-dev/libs",id:"wasm/sc-dev/libs",title:"Libraries",description:"OpenBrush",source:"@site/docs/wasm/sc-dev/libs.md",sourceDirName:"wasm/sc-dev",slug:"/wasm/sc-dev/libs",permalink:"/docs/wasm/sc-dev/libs",editUrl:"https://github.com/AstarNetwork/astar-docs/tree/main/docs/wasm/sc-dev/libs.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"ink! Development",permalink:"/docs/wasm/sc-dev/ink-dev"},next:{title:"Tools",permalink:"/docs/wasm/sc-dev/tools/"}},p={},u=[{value:"OpenBrush",id:"openbrush",level:2},{value:"Generic Trait Implementation",id:"generic-trait-implementation",level:3},{value:"Wrapper around Traits",id:"wrapper-around-traits",level:3},{value:"Documentation",id:"documentation",level:3},{value:"<code>parity-common</code>",id:"parity-common",level:3}],m={toc:u};function d(e){var t=e.components,n=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"libraries"},"Libraries"),(0,o.kt)("h2",{id:"openbrush"},"OpenBrush"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/Supercolony-net/openbrush-contracts"},"OpenBrush")," is a library for smart contract development on ink!. It intends to be like OpenZeppellin for ink!."),(0,o.kt)("p",null,"It provides standard contracts based on ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/w3f/PSPs"},"PSPs"),", as well as useful contracts and Rust macros to help you build ink! smart contracts."),(0,o.kt)("p",null,"Why use this OpenBrush?"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"To make contracts ",(0,o.kt)("strong",{parentName:"li"},"interoperable")," to do ",(0,o.kt)("strong",{parentName:"li"},"safe")," cross-contracts calls (by having the same function's signature among every contract)"),(0,o.kt)("li",{parentName:"ul"},"To ensure the usage of ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/w3f/PSPs"},"Polkadot Standards Proposals")),(0,o.kt)("li",{parentName:"ul"},"To ensure the usage of the ",(0,o.kt)("strong",{parentName:"li"},"latest and most secure")," implementation"),(0,o.kt)("li",{parentName:"ul"},"Useful contracts that provide custom logic to be implemented in contracts"),(0,o.kt)("li",{parentName:"ul"},"To ",(0,o.kt)("strong",{parentName:"li"},"save time")," by not writing boilerplate code"),(0,o.kt)("li",{parentName:"ul"},"Useful features which can simplify development")),(0,o.kt)("p",null,"Which standard tokens and useful contracts does it provide?"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"PSP22")," - Fungible Token (",(0,o.kt)("em",{parentName:"li"},"ERC20 equivalent"),") with extensions"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"PSP34")," - Non-Fungible Token (",(0,o.kt)("em",{parentName:"li"},"ERC721 equivalent"),") with extensions"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Multi-Token"),": ",(0,o.kt)("em",{parentName:"li"},"ERC1155 equivalent")," with extensions"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Ownable")," Restrict access to action for non-owners"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Access Control"),": Define a set of roles and restrict access to an action by roles"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Reentrancy Guard"),": Prevent reentrant calls to a function"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Pausable"),": Pause/Unpause the contract to disable/enable some operations"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Timelock Controller"),": Execute transactions with some delay"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Payment Splitter"),": Split the amount of native tokens between participants")),(0,o.kt)("h3",{id:"generic-trait-implementation"},"Generic Trait Implementation"),(0,o.kt)("p",null,"More importantly, OpenBrush adds support for generic Trait implementation so you can split Trait and Impls into different files, which will increase the readability and maintainability of your smart-contract code base (see detailed description ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/Supercolony-net/openbrush-contracts/blob/c71097ff10ef6d187bf9c86f0248bfbc6ec40a3c/docs/docs/smart-contracts/example/setup_project.md"},"here"),")"),(0,o.kt)("h3",{id:"wrapper-around-traits"},"Wrapper around Traits"),(0,o.kt)("p",null,"Defining a Trait definition is sufficient (a contract that implements that Trait is not needed anymore) to call methods of that Trait from some contract in the network (do a cross contract call). It makes cross-contract calls easier."),(0,o.kt)("h3",{id:"documentation"},"Documentation"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/Supercolony-net/openbrush-contracts"},"OpenBrush Github repo")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://docs.openbrush.io/"},"Official Docs")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://openbrush.io/"},"OpenBrush website")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=I5OFGNVvzOc"},"Substrate Seminar (Youtube)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://medium.com/supercolony/how-to-use-modifiers-for-ink-smart-contracts-using-openbrush-7a9e53ba1c76"},"How to use modifiers"))),(0,o.kt)("h3",{id:"parity-common"},(0,o.kt)("inlineCode",{parentName:"h3"},"parity-common")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/paritytech/parity-common"},(0,o.kt)("inlineCode",{parentName:"a"},"parity-common"))," is a collection of crates that you can use in your ink! contracts."),(0,o.kt)("p",null,"It offers all Ethereum types and is really useful if you want to port solidity code to ink!."))}d.isMDXComponent=!0}}]);